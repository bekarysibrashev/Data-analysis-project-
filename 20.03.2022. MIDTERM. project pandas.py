import pandas as pd #Вызываем библиотеку пандас
table = pd.read_csv("C:\\Users\\User\\Desktop\\Бекарыс\\pandas\\data.csv", delimiter=',')  #Считываем данные таблицы с помощью пандас(пд) и указываем путь, запятая делитель столбцов
df = pd.DataFrame(table) 


'''''''''''''''''''''''''''''ОБРАБОТКА 1 ЭТАП'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
data = df.notnull()     # ВОЗВРАЩАЕТ FALSE ЕСЛИ ЯЧЕЙКА В ТАБЛИЦЕ ПУСТА, т.е. пустые ячейки считываются как T or F 
                        #Создали мнимую таблицу DATA которая состоит из значений TRUE or FALSE
                        # ЕСЛИ TOTAL_INCOME  И  DAYS_EMPLOYED ПУСТЫЕ, ТО УДАЛЯЕТ ЭТИ СТРОКИ. ТАК КАК ЭТИ СТРОКИ НЕ ДАЮТ НАМ ПОЧТИ НИКАКУЮ ИНФОРМАЦИЮ

for i in range(len(df)): #цикл for от i(нулевого) будет повторяться по последнего индекса длины столбцов в таблице
    if data['total_income'][i] == False and data['days_employed'][i] == False: #Проверяем если оба условия соблюдены то ---->
        df = df.dropna() # DF.DROPNA УДАЛЯЕТ СТРОКУ ЕСЛИ ОНО ПОПАДАЕТ ПОД УСЛВИЕ   
                         # ПОСЛЕ УДАЛЕНИЯ СТРОКИ ИНДЕКСАЦИЯ СБИВАЕТСЯ. ТО ЕСТЬ ЕСЛИ БЫЛО 1 2 3 4 5 6.
                         # И УДАЛИЛИ 3 СТРОКУ. ТО ПОЛУЧИТСЯ 1 2 4 5 6(ПРОПУСТИТ 3)
                         # ТАК ВОТ ЧТО БЫ ЗАНОВО ПЕРЕ ИНДЕКСИРОВАТЬ ТАБЛИЦУ МЫ ИСПОЛЬЗУЕМ RESET_INDEX
df.reset_index(drop= True , inplace=True)     #делаем default индексацию
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
# 30000 let incorrect value
# used: absolute, round
'''''''''''''''''''''''''''''''''ОБРАБОТКА 2 ЭТАП'''''''''''''''''''''''''''''''''''''''''''''
def fix_years():             #Создаем функцию по исправлению столбцов days_employed and dob_years
    for i in range(len(df)):
        pos = abs(df['days_employed'][i])    #absolute = как результат дает нам модуль числа, то есть его положительное значение
        df['days_employed'][i] = pos/365     #превращаем дни в года и записываем в таблицу, чтобы понять где имеются неверные значения
        year = pos/365                       #создаем дополн. переменную для проверки данных 
        age = df['dob_years'][i]             #возраст человека  
        if df['gender'][i] == 'F':           #цикл для проверки ЖЕНСКОГО пола
            if 18<(age - year)<58:           #возраст - опыт работы(в годах) может быть от с 18 до 58(пенсионный возраст)
                df['days_employed'][i] = round(year)       #если соответсвтует данному условию то запишем округленное значение в столбец days_employed
            else:                            #иначе
                df['days_employed'][i] = 'INCORRECT VALUE' #заменчем на INCORRECT VALUE - анализу не подлежат данные, кто то работал 30000 лет
        if df['gender'][i] == 'M':           #Тоже самое для МУЖЧИН только возарст 63 года
            if 18<(age - year)<63:
                df['days_employed'][i] = round(year)    
            else:
                df['days_employed'][i] = 'INCORRECT VALUE'
    return df                           #РЕТУРН возварщает обработанные значения


'''''''''''''''''''''''''''''''''ОБРАБОТКА 3 ЭТАП'''''''''''''''''''''''''''''''''''''''''''''
#Разделяем на 5 типов кредита , уникальность проверяли с помощью value_counts

forwed = ['свадьба','на проведение свадьбы','сыграть свадьбу'] #list список
foreduc = ['заняться высшим образованием','дополнительное образование','высшее образование','образование','получение дополнительного образования',\
    'получение образования','профильное образование','получение высшего образования','заняться образованием']
forcar = ['на покупку своего автомобиля','автомобиль','сделка с автомобилем','сделка с подержанным автомобилем','автомобили',\
    'свой автомобиль','на покупку подержанного автомобиля','на покупку автомобиля','приобретение автомобиля']
forbus = ['покупка жилой недвижимости','операции с недвижимостью','покупка недвижимости','операции с коммерческой недвижимостью','строительство собственной недвижимости','недвижимость',\
    'операции со своей недвижимостью','строительство недвижимости','покупка коммерческой недвижимости']
forlive = ['операции с жильем','покупка жилья для сдачи','жилье','покупка своего жилья','покупка жилья','покупка жилья для семьи','ремонт жилью','строительство жилой недвижимости']

def credit_types():
    for i in range(len(df)):
        if df['purpose'][i] in foreduc:
            df['purpose'][i] = 'для образования'
        if df['purpose'][i] in forwed:
            df['purpose'][i] = 'для свадьбы'
        if df['purpose'][i] in forcar:
            df['purpose'][i] = 'для автомобиля'
        if df['purpose'][i] in forlive:
            df['purpose'][i] = 'для жилья'
        if df['purpose'][i] in forbus:
            df['purpose'][i] = 'для недвижимости'
    # с помощью value_counts видим каждые 5 типов по сколько раз встретились во всей таблицу
    # counter_credit = df.value_counts("purpose")
    # print(counter_credit)
#  возвращает таблицу с исправленными значениями по 5 типам кредита
    return df #Возвращает обновленный dataframe  с 5-ю видами кредитов
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




'''''''''''''''''''''''''''''''''ОБРАБОТКА 4 ЭТАП'''''''''''''''''''''''''''''''''''''''''''''
# EDUCATIOn REPAIRING
"""ЗАМЕНЯЕМ ПОХОЖИЕ ДУБЛИКАТЫ, таблица EDUCATION имеет одинаковые элементы разных регистров по\
     типу ВЫСШЕЕ и высшее, приводим их к Однородности"""
def education_types():                          #Создаем функцию для группирования идентичных элмеентов(разный регистр) 
    for i in range(len(df)):                    #опять по циклу проходим
        if df['education_id'][i] == 0:          #здесб education_id = 0 (где 0 это айди высшего), заменяем все значения столбца education на нижний регистр в соответствии с его i-тым значением
            df['education'][i] = str.lower(df['education'][i]) 
        if df['education_id'][i] == 1:
            df['education'][i] = str.lower(df['education'][i]) 
        if df['education_id'][i] == 2:
            df['education'][i] = str.lower(df['education'][i]) 
        if df['education_id'][i] == 3:
            df['education'][i] = str.lower(df['education'][i])  
        if df['education_id'][i] == 4:
            df['education'][i] = str.lower(df['education'][i]) 

    # counter_types = df.value_counts("education")
    # print(counter_types)
    return df
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''ОБРАБОТКА 5 ЭТАП'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''ОКРУГЛЯЕМ ЗАРПЛАТУ'''''''''''''''''''
def fix_salary():
    round_up_salary = round(df['total_income'])
    df['total_income'] = round_up_salary
    df['total_income'] = df['total_income'].fillna(60000) #fillna заполняем пустые ячейки столбца total_income на 60 000 МЗП
    return df




'''''Вызываем функции '''''''''
fix_years()
fix_salary()
education_types()
credit_types()

# РЕЗУЛЬТАТ ОБРАБОТКИ.
print(df) 



"""ANALYS"""
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''ЗАДАНИЕ (Есть ли связь между наличием детей и возвратом кредита в срок?)'''

child0 = 0   #создаем counter для пяти типов семей 0 1 2 3 4 количеством детей. КОЛИЧЕСТВО СЕМЕЙ ИМЕЮЩЕЕ 0 ДЕТЕЙ - для выявления соотношения
child1 = 0   #                                                                                           1 ДЕТЕЙ
child2 = 0
child3 = 0
child4 = 0
count_no_debt0 = 0 #counter для пяти типов семей, для того чтобы считать сколько не имеют из них долгов
count_no_debt1 = 0
count_no_debt2 = 0
count_no_debt3 = 0
count_no_debt4 = 0

# Этот цикл перебирает детей и долги

for i in range(len(df)):
    if df['children'][i] == 0:  #если в семье 0 детей, то для нулевых  в counter(child0) +1
        child0 += 1
        if df['debt'][i] == 0:      #далее попадает в цикл внутри, если у той семьи где 0 детей, еще и нет долгов то counter(count_no_debt)+1
            count_no_debt0 += 1
    if df['children'][i] == 1:  #Для семьи с 1 детей
        child1 += 1
        if df['debt'][i] == 0:  
            count_no_debt1 += 1
    if df['children'][i] == 2:  #Для семьи с 2 детей итд
        child2 += 1
        if df['debt'][i] == 0:
            count_no_debt2 += 1
    if df['children'][i] == 3: 
        child3 += 1
        if df['debt'][i] == 0:
            count_no_debt3 += 1    
    if df['children'][i] == 4:
        child4 += 1
        if df['debt'][i] == 0:
            count_no_debt4 += 1

percent0 = (count_no_debt0/child0)*100 #количество семей не имеющих долгов с нуля детьми / на общее количество семей где 0 детей *100% 
percent1 = (count_no_debt1/child1)*100
percent2 = (count_no_debt2/child2)*100
percent3 = (count_no_debt3/child3)*100
percent4 = (count_no_debt4/child4)*100

print(str(percent0) + ' % клиентов у которых 0 детей, НЕ ИМЕЮТ долги ')
print(str(percent1) + ' % клиентов у которых 1 детей, НЕ ИМЕЮТ долги ')
print(str(percent2) + ' % клиентов у которых 2 детей, НЕ ИМЕЮТ долги ')
print(str(percent3) + ' % клиентов у которых 3 детей, НЕ ИМЕЮТ долги ' )
print(str(percent4) + ' % клиентов у которых 4 детей, НЕ ИМЕЮТ долги\n ')

'''КОНЕЦ ЗАДАНИЯ (Есть ли связь между наличием детей и возвратом кредита в срок?)'''




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




'''ЗАДАНИЕ (Есть ли связь между семейным положением клиента и возвратом его или ее кредита с срок)'''
married = 0
single = 0

no_debt_married = 0
no_debt_single = 0

# Проверка семейных пар у которых нет долгов делается также как и с детьми 

for i in range(len(df)):
    # ЖЕНАТЫЕ(0) ИЛИ В ГРАЖДАНСКОМ БРАКЕ(1)
    if df['family_status_id'][i] == 0 or df['family_status_id'][i] == 1:
        # КЛИЕНТЫ В БРАКЕ.
        married += 1
        if df['debt'][i] == 0:
            no_debt_married += 1
    
    if df['family_status_id'][i] == 2 or df['family_status_id'][i] == 3 or df['family_status_id'][i] == 4 :
        # ВДОВА/ВДОВЕЦ(2) ИЛИ НЕ ЗАМУЖЕМ/ЖЕНАТ(4) ИЛИ В РАЗВОДЕ(3)
        single += 1
        if df['debt'][i] == 0:
            no_debt_single += 1

# Высчитывает процент возвращаемости кредита одиноких клиентов и клиентов в браке
percent_married = (no_debt_married/married) * 100
percent_single = (no_debt_single/single) * 100

print(str(percent_married) + ' % людей в браке не имеют долгов ')
print(str(percent_single) + ' % одиноких людей не имеют долгов\n ')

''' КОНЕЦ ЗАДАНИЯ (Есть ли связь между семейным положением клиента и возвратом его или ее кредита с срок)'''

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'''ЗАДАНИЕ (Влиеят ли уровень дохода на возврат кредита в срок?)'''


# ОКРУГЛЯЕМ ЗНАЧЕНИЯ  total_income  и  сохраняем их в таблице
round_up_salary = round(df['total_income'])
df['total_income'] = round_up_salary

# НАХОДИМ СРЕДНЮЮ ЗАРПЛАТУ ИЗ ВСЕХ В СТОЛБЦЕ total_income
tot_inc = df.mean(axis=0)    #нахождение среднеарифметического значения 
average_salary = tot_inc['total_income']

# Пустые переменные для подсчета  как counter = счетчики
# Число богатых у которых нет долгов
rich_no_debt = 0
# Число бедных у которых нет долгов
poor_no_debt = 0

# Общее число бедных и богатых клиентов 
count_rich = 0
count_poor = 0
'''0''''''''''''''''''бедные''''''''''''''150 000''''''''''''''''''богатые''''''''''''''''''''''300 000'
for i in range(len(df)):
    # Проверка для богатых
    if df['total_income'][i] > average_salary:
        count_rich +=1                  #к кол-ву богатых +1
        if df['debt'][i] == 0:          
            rich_no_debt += 1           #к колву богатых не имеющих долг + 1 
    
    # Проверка для бедных
    if df['total_income'][i] < average_salary:
        count_poor += 1                 #к кол-ву бедных +1 
        if df['debt'][i] == 0:  
            poor_no_debt += 1           #к кол-ву бедных не имеющих долг +1
        
rich_relation = (rich_no_debt/count_rich)*100  #вычесляем отношение богатых без долгов к общему количеству
poor_relation = (poor_no_debt/count_poor)*100  #вычесляем отношение бедных без долгов к общему кол-ву

print('\nПроцент богатых не имеющих долгов '+ str(rich_relation))
print('Процент бедных не имеющих долгов '+str(poor_relation))

if rich_relation>poor_relation:
    print('Статистика показывает, что отношение богатых не имеющих долг больше чем бедных не имеющих долг, \
        соответственно вероятнее всего доход человека напрямую влияет на факт погашения кредита в срок\n')
else:
    print('Доход человека не влияет на факт погашения кредита в срок\n')

'''КОНЕЦ ЗАДАНИЯ (Влиеят ли уровень дохода на возврат кредита в срок?)'''






''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'''ЗАДАНИЕ (Какие типы кредитов больше всего возвращаются в срок)'''

# forwed = ['свадьба','на проведение свадьбы','сыграть свадьбу']

# foreduc = ['заняться высшим образованием','дополнительное образование','высшее образование','образование','получение дополнительного образования',\
#     'получение образования','профильное образование','получение высшего образования','заняться образованием']

# forcar = ['на покупку своего автомобиля','автомобиль','сделка с автомобилем','сделка с подержанным автомобилем','автомобили',\
#     'свой автомобиль','на покупку подержанного автомобиля','на покупку автомобиля','приобретение автомобиля']

# forbus = ['покупка жилой недвижимости','операции с недвижимостью','покупка недвижимости','операции с коммерческой недвижимостью','строительство собственной недвижимости','недвижимость',\
#     'операции со своей недвижимостью','строительство недвижимости','покупка коммерческой недвижимости']

# forlive = ['операции с жильем','покупка жилья для сдачи','жилье','покупка своего жилья','покупка жилья','покупка жилья для семьи','ремонт жилью','строительство жилой недвижимости']

# for i in range(len(df)):
#     if df['purpose'][i] in foreduc:
#         df['purpose'][i] = 'для образования'
#     if df['purpose'][i] in forwed:
#         df['purpose'][i] = 'для свадьбы'
#     if df['purpose'][i] in forcar:
#         df['purpose'][i] = 'для автомобиля'
#     if df['purpose'][i] in forlive:
#         df['purpose'][i] = 'для жилья'
#     if df['purpose'][i] in forbus:
#         df['purpose'][i] = 'для недвижимости'
#     for i in df.columns:
#         if df[i].dtypes == 'object':
#             num = i 
#             a = df[i].unique()

feduc = 0
fbus = 0
fhome = 0
fcar = 0
fwed = 0
# Те кто взял кредит на свадьбу
net_dolga1 = 0

# Те кто взял кредит на жилье
net_dolga2 = 0

# Те кто взял кредит на недвижимость
net_dolga3 = 0

# Те кто взял кредит на автомобиль
net_dolga4 = 0

# Те кто взял кредит на образование 
net_dolga5 = 0


for i in range(len(df['purpose'])):
    if df['purpose'][i] == 'для свадьбы':
        fwed += 1
        if df['debt'][i] == 0:
            net_dolga1 += 1
        
    if df['purpose'][i] == 'для жилья':
        fhome += 1
        if df['debt'][i] == 0:
            net_dolga2 += 1
        

    if df['purpose'][i] == 'для недвижимости':
        fbus += 1
        if df['debt'][i] == 0:
            net_dolga3 += 1
        
    if df['purpose'][i] == 'для автомобиля':
        fcar += 1
        if df['debt'][i] == 0:
            net_dolga4 += 1
        
    if df['purpose'][i] == 'для образования':
        feduc += 1
        if df['debt'][i] == 0:
            net_dolga5 += 1

# Подсчитываем проценты на разные виды кредитов 
percent5 = (net_dolga5/feduc)* 100
percent4 = (net_dolga4/fcar)* 100
percent3 = (net_dolga3/fbus)* 100
percent2 = (net_dolga2/fhome)* 100
percent1 = (net_dolga1/fwed)* 100

# Показываем на экран, и делаем выводы
print(str(percent1)+ '% возвращаемость кредита на свадьбу ')
print(str(percent2)+ '% возвращаемость кредита на жилье ')
print(str(percent3)+ '% возвращаемость кредита на недвижимость ')
print(str(percent4)+ '% возвращаемость кредита на автомобиль ')
print(str(percent5)+ '% возвращаемость кредита на образование\n')

'''КОНЕЦ ЗАДАНИЯ (Какие типы кредитов больше всего возвращаются в срок)'''


